#' plot_STcellchat
#'
#' plot_STcellchat draws the spatially resolved cell-cell interaction onto the image
#'
#' @param cellchat a CellChat object generaged by STIE::get
#' @param cell_dist a data frame representing the distance between cell pairs
#' @param im an image object generated by the magick::image_read() function
#' @param image_transparency a numeric value from 0 to 1 representing the transparency for plotting the image
#' @param w an integer value representing the width for cropping the image
#' @param h an integer value representing the height for cropping the image
#' @param xoff an integer value representing the offset on X-axis for cropping the image
#' @param yoff an integer value representing the offset on Y-axis for cropping the image
#' @param x_scale a numeric value from 0 to 1 for resizing the image
#' @param plot_object a character value representing the pathway or pattern of interest to plot  
#' @param direction a character value taking "outgoing" or "incoming", representing the sending or receiving signal for the plot_object
#' @param prob_cutoff a numeric value representing the probability cutoff of interaction signal for plotting the plot_object
#' @param color_use a vector of character values representing colors to plot cell types, which ara ranked based on alphabetical order
#' @param lwd a numeric value representing the thickness of edge for cell-cell interaction
#' @param plot_cell a boolean value representing whether to plot cell contours
#' @param contour a list of matrics with each item representing one cell contour
#'
#' 
#' @author Shijia Zhu, \email{shijia.zhu@@utsouthwestern.edu}
#' @export
#'
#' @seealso \code{\link{get_STcellchat}}; 
#' 
#' 
plot_STcellchat <- function(cellchat, cell_dist, 
                            im, image_transparency=0, 
                            w=NULL, h=NULL, xoff=0, yoff=0, x_scale=1,
                            plot_object, direction=c("outgoing","incoming"), prob_cutoff=0,
                            color_use=NULL, lwd=10,
                            plot_cell=FALSE, contour=NULL) {
    
    # 1. if pathway, draw on pathway
    # 2. else draw weight of all pathways
    # 3. draw pattern together and separately
    # 4. draw in and out
    
    direction = match.arg(direction)
    
    ######### pathway_probs
    # count <- cellchat@net$count
    # weight <- cellchat@net$weight
    pathway_names = cellchat@netP$pathways
    pathway_probs = cellchat@netP$prob
    for(i in 1:dim(pathway_probs)[3]) pathway_probs[,,i] = pathway_probs[,,i]*(pathway_probs[,,i]>=prob_cutoff)
    
    
    patternSignaling <- methods::slot(cellchat, "netP")$pattern [[ direction ]]
    data = patternSignaling$data
    data1 = patternSignaling$pattern$cell
    data2 = patternSignaling$pattern$signaling
    
    ######### pattern_probs
    pattern_names = sort(unique(as.character(data1$Pattern)))
    
    pattern_probs = lapply( pattern_names, function(pattern) {
        r1 = subset(data1, Pattern==pattern)$Contribution
        if( direction=="outgoing" ) r1 = matrix( r1, nrow=length(r1), ncol=length(r1), byrow=F )
        if( direction=="incoming" ) r1 = matrix( r1, nrow=length(r1), ncol=length(r1), byrow=T )
        tmp = lapply( pathway_names, function(pathway) {
            r2 = subset(data2, Pattern==pattern & Signaling==pathway)$Contribution    
            r1 * r2 * pathway_probs[,,pathway]
        })
        dat = tmp[[1]]
        for(i in 2:length(tmp)) dat=dat+tmp[[i]]
        dat
    })
    names(pattern_probs) = pattern_names
    
    if( ! plot_object%in%pattern_names & ! plot_object%in%pathway_names )
    {
        cat( "ERROR: plot_object should be in the followings:\n" )
        cat( "Patterns:\n" )
        print(pattern_names)
        cat( "Pathways:\n" )
        print(pathway_names)
        
    } else {
        
        if( !is.null(w) & !is.null(h) ) {
            im <- im %>% image_crop(geometry = geometry_area(width = w, height = h, x_off = xoff, y_off = yoff))
        } else {
            iminf <- image_info(im)
            w = iminf$width
            h = iminf$height
        }
        
        if (x_scale<1) {
            iminf <- image_info(im)
            print(paste0("Image width: ", iminf$width))
            print(paste0("Image width after scaling: ", x_scale*iminf$width))
            im <- im %>%
                image_scale(paste0(round(x_scale*iminf$width))) 
        }
        
        im <- im %>% as_EBImage()
        
        if( image_transparency>=0 & image_transparency<=1 ) 
        {
            im <- (1-image_transparency)*im + image_transparency*(im*0+1)
        }
        
        ########################################################################################
        cells_on_spot = STIE_result$cells_on_spot
        cell_types = STIE_result$cell_types
        
        uni_celltypes = sort(unique(cell_types))
        if(is.null(color_use)) color_use = get_my_colors(length(uni_celltypes), mode=2)
        names(color_use) = uni_celltypes
        cell_cols = color_use[cell_types]
        #interaction_cols = color_use[cell_types]
        
        pixel_x = ( cells_on_spot$X - xoff )*x_scale
        pixel_y = ( cells_on_spot$Y - yoff )*x_scale
        cell_coordinates = data.frame(pixel_x, pixel_y)
        
        plot_range = with(cell_coordinates, which( pixel_x>0 & pixel_y>0 &
                                  pixel_x<w*x_scale & pixel_y<h*x_scale ) )
        cell_dist = cell_dist[cell_dist$i%in%plot_range & cell_dist$j%in%plot_range, ]
        
        #################################################################################
        ######### plot interaction
        #################################################################################
        
        if(plot_object%in%pattern_names) cci = pattern_probs[[ plot_object ]]
        if(plot_object%in%pathway_names) cci = pathway_probs[ , , plot_object ]
        
        mfrow = par()$mfrow
        mar = par()$mar
        
        mat1 <- matrix(1:2, ncol=2, nrow=1)
        layout(mat1, widths=c(8, 2), heights=c(1, 2))
        
        plot(im)
        
        cat("Plotting interactions ... \n")
        for(k in 1:nrow(cell_dist))
        {
            i = cell_dist$i[k]
            j = cell_dist$j[k]
            ci = cell_types[i]
            cj = cell_types[j]
            if( direction=="outgoing" ) {
                coli = color_use[ci]
                colj = color_use[cj]
            }
            if( direction=="incoming" ) {
                coli = color_use[cj]
                colj = color_use[ci]
            }
            lines( cell_coordinates[c(i,j),], col=coli, lty=2, lwd=lwd*cci[ci,cj] )
            lines( cell_coordinates[c(i,j),], col=colj, lty=3, lwd=lwd*cci[cj,ci]  )
            # cat(k,cci[ci,cj],"\n")
            
        }
        
        print(cci)
        
        if(plot_cell) {
            contour = contour[ match(names(cell_types), names(contour)) ]
            plot_cell_contour(contour, cells_on_spot, w, h, xoff, yoff, x_scale, cell_cols)
        }
        
        par(mar = c(0, 0, 0, 0))
        plot.new()
        legend = uni_celltypes
        title = paste0( plot_object, ": ", direction )
        legend('topleft', legend=legend, lty=1, lwd=3, col=color_use, 
               box.lwd = 0, box.col = "white",bg = "white", 
               title=title, title.adj=0.1 )
        
        
        par( mfrow=mfrow )
        par( mar=mar)
        
    }
    
    
}

